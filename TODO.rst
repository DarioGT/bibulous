Python code to-do
-----------------

#. For each "Warning..." message, add a numerical tag so we know which line in the
   code they come from. (Identical messages can come from different points in
   the code, such as when the code can't find an abbreviation key.)

#. Since we've defined special fields ``<authorlist``> etc, we must have functions which
   insert these fields into the main bibdata dictionary so that users can have direct access
   to them in the template file. Also, note that we have not been consistent with ``<authorlist>``
   and ``<editorlist>``, since you document that these are lists of dictionaries, whereas in the
   template itself, you substitute ``<authorlist>`` as a simple string!

#. TEMPLATE LANGUAGE: Add a *name template* to the BST file, so that the template can tell the
   software how to format names without using so many options settings. Test implementing the
   "last_name_then_first" option to authorlist/editorlist formatting. Then, write a template
   function which prints the "pages" field as-is if there is a comma in the field, else it
   formats as ``<startpage>--<endpage>``. This will allow page ranges like "64--66, 87--92, 94"
   to appear in the bibliography.

   Potential example for the way to define an authorlist::

      nameformat.name = name.first.initial~name.middle.initial [name.prefix] name.last[, name.suffix]
      nameformat.<authorlist>.[nauthors==1] = nameformat.<authorlist>.0
      nameformat.<authorlist>.[nauthors==2] = nameformat.<authorlist>.0 + ' and ' + nameformat.<authorlist>.1
      nameformat.<authorlist>.[nauthors==3] = nameformat.<authorlist>.0 + ', ' + nameformat.<authorlist>.1 + ', and ' + nameformat.<authorlist>.2
      nameformat.<authorlist>.[nauthors==MAX] = (nameformat.<authorlist>.0 + ', ') ... (nameformat.<authorlist>.[MAX-1]) + ', and ' + nameformat.<authorlist>.max
      nameformat.<authorlist>.[nauthors>MAX] = (nameformat.<authorlist>.0 + ', ') ... (nameformat.<authorlist>.[MAX-1]) + ', ' + nameformat.<authorlist>.max + ', \\textit{et al.}'

#. Look into the output generated by using ``natbib`` --- especially when using the ``\citep``,
   ``\citet``, ``\citep*``, and ``\citet*`` commands. Anything you need to do differently here? How
   about the ``\citeyear`` and ``\citeauthor`` commands? This will also allow you to try implementing the
   ``anyt`` and ``anyvt`` citation order options, since these require alphabetic labels in the
   citation list given in the ``*.aux`` file.

#. Add an option allowing the ``month`` field to be written out in full or in abbreviated form.
   Also Allow the ``month`` field in an entry to be numeric and not just alpha? That is,
   automatically convert a numeric value to a locale-based description of the month. I started
   putting this in (see ``test_locale_dependent_sorting.py``), and it's clear that the best way to
   do this is using the ``locale`` module.

#. Remember that the mandatory argument to ``\thebibliography`` in the preamble of the BBL
   file is the longest label occurring in the list. For numeric formats, this is simplify
   the largest number. For alpha-formats, it will be more complicated! This argument, if I
   understand it, is actually the amount of hanging indent used by the bibliography. How to
   allow users a more flexible way of setting this?

#. ``format_edition()``, as currently implemented, will only work for English-language
   bibliographies. This needs to be modified so that it can be made multilingual.

#. Make sure that when an exception has occurred, you still generate a valid BBL file (just
   an incomplete one). So you will need to make use of some try...except blocks.

#. Write a ``bibclean`` function which checks a ``*.bib`` file for errors. Include using
   ``namefield_to_namelist(`` to check for name format errors. A common problem will be encoding
   errors. For this, you can use ``fix_bad_unicode.py``, which attempts to undo encoding errors.
   Actually, it looks like this code has been turned into a regular Python package ``ftfy``.
   The file you have works for Python2 and not Python3, but the package is compatible with
   both.

#. Allow nesting of square brackets ``[|]`` --- i.e. options within options. Needed?

#. Note that ``biblatex`` does *not* use ``\bibliography{...}`` to add a ``*.bib`` database.
   Rather, in the preamble, it uses ``\addbibresource{...}``. And it doesn't use
   ``\bibliographystyle{...}``
   either. Instead, it just uses ``\printbibliography``, while all the style stuff is input in
   the document preamble (esp. using ``*.bbx`` files). Do these preamble additions put entries
   into the AUX file that you can parse?

#. Implement a bibliography format in which repeated duplicates of author names are replaced
   with a long dash. (Or ``\textit{idem}`` instead of the dash?)

#. Currently Arabic prefixes of names, like al-Turabi, will produce a space between the ``al-``
   and the last name. Need to fix.

#. For people who want to write TeX/LaTeX files in Unicode, but need to deliver an ascii file
   to a journal for their internal processing, maybe you can write a function which does the
   inverse of purify_string(). That is, it converts Unicode characters into their LaTeX
   encoded equivalents. If you work on this, the ``bibtexparser`` module has a good deal of code
   for starting on this.

#. On page 130 of the Biblatex documentation, it lists a ``postnote`` option to the ``\cite{}``
   command, in which the writer can enter in either a numeric page number to refer to, or a
   string that is intended to be directly appended to the line. Find a way to implement this.
   Maybe add a ``postnote`` field to the bibdata entry, and allow that field to be a list in case
   more than one citation uses different page references to the same document?

#. Test the ``labelalpha`` field in ``.aux`` files for citation order options ``anyt`` and
``anyvt``.

#. From the Bibulus paper (the XML-based BibTeX replacement, not your Bibulous): BibTeX requires
   us to write notes and annotations in the bibliographic database, but there are problems with
   this approach. Annotations are typically unique to each bibliography (this is often true for
   notes, too). The bibliographic database is therefore the wrong place to specify them -- it
   should be done in the main text instead. Furthermore, these fields require translation when
   the document is translated, something which is much easier if they are kept together with
   the main text. Allow both for backwards compatibility.

#. Show how to use Bibulous to create a glossary. (See ``gloss.pdf`` file for
   some good suggestions.)

#. Should Bibulous add ``\bibcite{}{}`` lines to the AUX files in the same way that BibTeX does?
   Who uses that? For that matter, should you make any use of the ``.blg`` file? How does BibTeX
   use it?

#. Add a function which checks to see if ``endpage==startpage``. If so, then don't define the
   ``endpage``. Also issue a warning if ``endpage`` and ``startpage`` are both numbers and
   ``endpage <= startpage``.

#. Note that there is an option ``use_firstname_initials``. But you don't have options for any
   other types of initials.

Python testing to-do
--------------------

#. I guess you will need to make some change to the description above in order to test
    formatting options, since these are set once by the BST file and are not dynamic after
    that.

#. Add tests for each of the following::
        options.citation_order
        options.sort_case
        options.warnings
        options.backrefs
        options.backrefstyle
        options.hyperref
        options.use_abbrevs
        options.sort_with_prefix
        options.period_after_initial
        options.terseinits
        options.missing_data_exceptions
        options.use_csquotes
        options.authorlist_format
        options.use_author_firstname_initials
        options.use_editor_firstname_initials
        options.editorlist_format
        options.namelist_format
        options.use_name_ties

#. Test ``purify_string()`` on the following::

        s1 = r"Recherches exp{\'e}rimentales sur la g{\'e}n{\'e}ralisation de l'emploi du spectrom{\`e}tre {F}abry-{P}erot"
        s2 = r'Vorschl{\"a}ge zur {C}onstruction einiger optischer {V}orichtungen'
        s3 = u'¡Hola! ¿Cómo estás? ¿Está bien así en español?'
        s4 = r'C{\'o}mo est{\'a}s? Est{\'a} bien as{\'\i} en espa{\~n}ol?'
        s5 = u'Smør brød på hytte taket'
        s6 = r'Sm{\o}r br{\oo}d p{\aa} hytte p{\aab} taket'
        s7 = u"Keiyodashi Jun'ichiro"
        s8 = r'\{\{ $\left[.\left\lfloor \frac{5}{\frac{\left(3\right)}{4}} \right).\right]$ \}\}'

        print('s1 = ' + s1)
        print('s2 = ' + s2)
        print('s3 = ' + s3)
        print('s4 = ' + s4)
        print('s5 = ' + s5)
        print('s6 = ' + s6)
        print('s7 = ' + s7)
        print('s8 = ' + s8)
        print('')

        p1 = purify_string(s1)
        p2 = purify_string(s2)
        p3 = purify_string(s3)
        p4 = purify_string(s4)
        p5 = purify_string(s5)
        p6 = purify_string(s6)
        p7 = purify_string(s7)
        p8 = purify_string(s8)

        print('p1 = ' + p1)
        print('p2 = ' + p2)
        print('p3 = ' + p3)
        print('p4 = ' + p4)
        print('p5 = ' + p5)
        print('p6 = ' + p6)
        print('p7 = ' + p7)
        print('p8 = ' + p8)
        print('')

    Note that this also tests Unicode-compatibility.

#. Test the Unicode compatibility of ``generate_sortkey()``.

#. Add a test for ``bibulous-authorextract``. For example, for one test, try something like::
       bibulous-authorextract.write_authorextract(texfile, auxfile, {'last':'Hagen', 'first':'Nathan'})

#. Add a test for ``bibulous-citeextract``.

#. Test that trying to import a BibTeX-format BST file generates an ``ImportError`` exception.

#. Test proper formatting of the ``edition`` field.

#. Test for missing fields in entries.

#. The entry ``pagerange1`` has a comma-delimited page range. Currently you don't have a
    template that allows one to differentiate formatting to use the ``<pages>`` when there are
    commas in the field, whereas one uses ``<startpage>--<endpage>`` when there are no commas.
    Once you get the general parser working, give this functionality a try.

Template files to-do
--------------------

#. Now that you have a ``bibulous-authorextract`` script, write a
   ``cvpublications.bst`` style template file to go with it. Bibliography sections: "peer
   reviewed journal articles", "conference proceedings papers", "presentations".

#. Show a style template that implements an annotated bibliography using the "annotation"
   field in the .bib database.

#. Try implementing some other BST formats, especially OSA's Opt. Lett. and SPIE's Opt. Eng.
   Note that ``chicago.sty`` uses ``chicago.bst``, and ``apalike.sty`` uses ``apalike.bst``.

#. Allow the parsing engine a means of setting, for example, fieldname ``authors`` to get mapped
   to fieldname ``author``. Maybe::

        if <fieldname> == 'authors': <fieldname> == 'author'

   or something like that.
